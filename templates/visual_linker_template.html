<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Visual Linker</title>
    <script src="assets/echarts.min.js"></script>
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
    <style>
        * { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background: #111827;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        #chart-container {
            width: 100%;
            height: 100%;
        }
        .hint-overlay {
            position: absolute;
            top: 10px;
            right: 16px;
            background: rgba(15,23,42,0.9);
            border-radius: 10px;
            padding: 8px 12px;
            color: #9ca3af;
            font-size: 11px;
            border: 1px solid rgba(148,163,184,0.4);
            backdrop-filter: blur(12px);
            z-index: 10;
        }
        .hint-overlay b {
            color: #e5e7eb;
        }
    </style>
</head>
<body>
<div id="chart-container"></div>
<div class="hint-overlay">
    <div><b>Создание связи:</b></div>
    <div>1) Клик по Донору</div>
    <div>2) Клик по Таргету</div>
    <div style="margin-top:4px;">Серые стрелки — существующие ссылки,<br>зелёные — новые (план).</div>
</div>

<script>
    // ─────────────────────────────────────
    // Глобальные переменные для графа
    // ─────────────────────────────────────
    let chart = null;
    let allNodes = [];
    let existingEdges = [];
    let plannedEdges = [];

    // Режим создания связи: клик по донору, затем по таргету
    let linkMode = {
        active: false,
        sourceId: null
    };

    // Мост Qt WebChannel
    let bridge = null;
    new QWebChannel(qt.webChannelTransport, function(channel) {
        bridge = channel.objects.bridge;
    });

    // ─────────────────────────────────────
    // Рендер графа
    // ─────────────────────────────────────
    function renderGraph() {
        const dom = document.getElementById('chart-container');
        if (!chart) {
            chart = echarts.init(dom, null, { renderer: 'canvas' });
        }

        // Узлы
        const data = allNodes.map(n => {
            const isPillar = n.isPillar;
            return {
                id: n.id,
                name: n.label,
                value: 1,
                symbolSize: isPillar ? 46 : 24,
                draggable: true,
                itemStyle: {
                    color: isPillar ? '#f97316' : '#3b82f6',
                    borderColor: '#ffffff',
                    borderWidth: 1.6,
                    shadowBlur: 12,
                    shadowColor: 'rgba(0,0,0,0.5)'
                },
                label: {
                    show: true,
                    color: '#e5e7eb',
                    fontSize: 11,
                    position: 'right'
                }
            };
        });

        // Собираем карту для проверки взаимных связей (A->B и B->A)
        const allEdgesRaw = []
            .concat(existingEdges || [])
            .concat(plannedEdges || []);

        const edgeSet = new Set(
            allEdgesRaw.map(e => (e.source || '') + '->' + (e.target || ''))
        );

        function isMutualEdge(src, tgt) {
            return edgeSet.has(tgt + '->' + src);
        }

        // Существующие ссылки (серые)
        const linksExisting = (existingEdges || []).map(e => {
            const mutual = isMutualEdge(e.source, e.target);
            return {
                source: e.source,
                target: e.target,
                lineStyle: {
                    color: '#6b7280',
                    width: 1.2,
                    opacity: 0.9,
                    // если связь взаимная, рисуем дугу, чтобы было видно обе
                    curveness: mutual ? 0.2 : 0.0
                },
                emphasis: {
                    lineStyle: {
                        width: 2
                    }
                }
            };
        });

        // Новые (планируемые) ссылки (зелёные)
        const linksPlanned = (plannedEdges || []).map(e => {
            const mutual = isMutualEdge(e.source, e.target);
            return {
                source: e.source,
                target: e.target,
                lineStyle: {
                    color: '#22c55e',
                    width: 1.8,
                    opacity: 0.95,
                    // у встречной связи дуга в другую сторону
                    curveness: mutual ? -0.2 : 0.1
                },
                tooltip: {
                    show: !!e.anchor,
                    formatter: function () {
                        return e.anchor ? 'Anchor: ' + e.anchor : 'New link';
                    }
                }
            };
        });

        const option = {
            backgroundColor: '#111827',
            tooltip: {
                formatter: function (params) {
                    if (params.dataType === 'node') {
                        const node = allNodes.find(n => n.id === params.data.id);
                        if (!node) return params.name;
                        const type = node.isPillar ? 'Pillar' : 'Page';
                        return '<b>' + type + '</b><br/>' +
                               '<span style="font-size:11px;color:#9ca3af;">' + (node.url || '') + '</span>';
                    }
                    return '';
                }
            },
            series: [{
                type: 'graph',
                layout: 'force',
                roam: true,
                draggable: true,
                data: data,
                links: linksExisting.concat(linksPlanned),
                focusNodeAdjacency: true,

                // СТРЕЛКИ НА КРАЯХ
                edgeSymbol: ['none', 'arrow'],
                edgeSymbolSize: [0, 8],

                force: {
                    repulsion: 120,
                    gravity: 0.1,
                    edgeLength: [80, 180]
                },
                lineStyle: {
                    opacity: 0.9
                }
            }]
        };
        chart.setOption(option);

        // Клик по ноде: режим создания связи Donor -> Target
        chart.off('click');
        chart.on('click', function (params) {
            if (params.dataType !== 'node') {
                linkMode.active = false;
                linkMode.sourceId = null;
                return;
            }
            const nodeId = params.data.id;

            if (!linkMode.active) {
                // Выбрали донора
                linkMode.active = true;
                linkMode.sourceId = nodeId;
            } else {
                // Выбрали таргет
                const sourceId = linkMode.sourceId;
                const targetId = nodeId;
                linkMode.active = false;
                linkMode.sourceId = null;

                if (bridge && bridge.createLink) {
                    bridge.createLink(sourceId, targetId);
                }
            }
        });

        window.addEventListener('resize', () => chart.resize());
    }

    // ─────────────────────────────────────
    // API для Python
    // ─────────────────────────────────────

    // Python вызывает это после сканирования
    window.initVisualGraph = function(payload) {
        allNodes = payload.nodes || [];
        existingEdges = payload.existingEdges || [];
        plannedEdges = payload.plannedEdges || [];
        renderGraph();
    };

    window.addPillarNode = function(node) {
        allNodes.push(node);
        renderGraph();
    };

    window.addPlannedLink = function(edge) {
        plannedEdges.push(edge);
        renderGraph();
    };
</script>
</body>
</html>
